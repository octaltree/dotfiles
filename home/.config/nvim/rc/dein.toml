[[plugins]]
repo = 'Shougo/context_filetype.vim'
[[plugins]]
repo = 'tpope/vim-surround'
[[plugins]]
repo = 'Shougo/neco-syntax'
[[plugins]]
repo = 'vim-jp/vimdoc-ja'

[[plugins]] # linearf {{{
repo = 'octaltree/linearf'
hook_add='''
lua<<EOF
local linearf = require('linearf')
--linearf._debug = true
local flavors = require('linearf-my-flavors')
linearf.init(require('linearf-vanilla').new())
linearf.recipe.sources = {
    {name = "identity", path = "flavors_plain::Identity"},
    {name = "command", path = "flavors_tokio::Command"}
}
linearf.recipe.matchers = {
    {name = "identity", path = "flavors_plain::Identity"},
    {name = "substring", path = "flavors_plain::Substring"}
}
linearf.recipe.converters = {
    {name = "format_line", path = "flavors_plain::FormatLine"}
}
local alias_escape_querier = {
      linearf = {
          list_nnoremap = {},
          querier_inoremap = {
              ["<A-space>"] = flavors.normal_and(flavors.actions.view.goto_list)
          },
          querier_nnoremap = {["<A-space>"] = flavors.actions.view.goto_list}
      }
}
linearf.senarios['line'] = flavors.merge {
    flavors.senarios['line'],
    flavors.senarios.quit,
    flavors.senarios.no_list_insert,
    flavors.senarios.no_querier_normal,
    alias_escape_querier,
    {
        linearf = {
            list_nnoremap = {
                ["<CR>"] = flavors.hide_and(flavors.actions.line.jump)
            },
            querier_inoremap = {
                ["<CR>"] = flavors.normal_and(
                    flavors.hide_and(flavors.actions.line.jump))
            }
        },
        view = {querier_on_start = 'insert'}
    }
}
linearf.context_managers['line'] = flavors.context_managers['line']
linearf.senarios['file'] = flavors.merge {
    flavors.senarios['file_rg'],
    flavors.senarios.quit,
    flavors.senarios.no_list_insert,
    flavors.senarios.no_querier_normal,
    alias_escape_querier,
    {
        linearf = {
            list_nnoremap = {
                ["<CR>"] = flavors.hide_and(flavors.actions.file.open),
                ["<nowait>s"] = flavors.hide_and(flavors.actions.file.split),
                ["t"] = flavors.hide_and(flavors.actions.file.tabopen),
                ["v"] = flavors.hide_and(flavors.actions.file.vsplit)
            },
            querier_inoremap = {
                ["<CR>"] = flavors.normal_and(
                    flavors.hide_and(flavors.actions.file.open))
            }
        }
    }
}
linearf.context_managers['file'] = flavors.context_managers['file_rg']
linearf.senarios['grep'] = flavors.merge {
    flavors.senarios['grep_rg'],
    flavors.senarios.quit,
    flavors.senarios.no_list_insert,
    flavors.senarios.enter_list,
    {
        linearf = {
            list_nnoremap = {
                ["<CR>"] = flavors.hide_and(flavors.actions.grep.open),
                ["<nowait>s"] = flavors.hide_and(flavors.actions.grep.split),
                ["t"] = flavors.hide_and(flavors.actions.grep.tabopen),
                ["v"] = flavors.hide_and(flavors.actions.grep.vsplit)
            },
            querier_inoremap = {},
            querier_nnoremap = {
                ["<nowait><ESC>"] = flavors.actions.view.goto_list,
                ["<A-space>"] = flavors.actions.view.goto_list
            }
        }
    }
}
linearf.context_managers['grep'] = flavors.context_managers['grep_rg']

linearf.bridge.try_build_if_not_exist = true
linearf.bridge.try_build_on_error = false
EOF

nnoremap <space>/ :<c-u>lua lnf('line')<CR>
nnoremap <space>f :<c-u>lua lnf('file')<CR>
nnoremap <space>g :<c-u>lua lnf('grep')<CR>
'''
[[plugins]]
repo = 'octaltree/linearf-my-flavors'
# }}}

[[plugins]] # treesitter {{{
repo = 'nvim-treesitter/nvim-treesitter'
hook_add='''
lua<<EOF
local success, ts_config = pcall(require, 'nvim-treesitter.configs')
if success then
  ts_config.setup {
    highlight = {
      enable = true,
      disable = {'json', 'csv'}
    }
  }
end
EOF

"augroup cmdwin_highlight
"  au!
"  au CmdwinEnter * syntax on
"augroup END
''' # }}}

[[plugins]] # solarized {{{
repo = 'lifepillar/vim-solarized8'
hook_add='''
let g:solarized_termtrans=1
let g:solarized_extra_hi_groups = 1
autocmd VimEnter * nested colorscheme solarized8
autocmd ColorScheme * hi Folded guifg=#839496 guibg=None guisp=#002b36 gui=None cterm=None
autocmd ColorScheme * hi NormalFloat guibg=None
''' # }}}

[[plugins]] # whitespace {{{
repo = 'bronson/vim-trailing-whitespace'
hook_add='''
let g:extra_whitespace_ignored_filetypes=['denite', 'markdown']
autocmd BufRead,BufNewFile * if ShouldMatchWhitespace() | match ExtraWhitespace /\\\@<![\u3000[:space:]]\+$/ | else | match ExtraWhitespadce /^^/ | endif
''' # }}}

[[plugins]] # nerdcommenter {{{
repo = 'preservim/nerdcommenter'
hook_add = '''
let g:NERDDefaultAlign = 'left'
''' # }}}

[[plugins]] # vimproc {{{
repo = 'Shougo/vimproc.vim'
build = 'make'
# }}}

[[plugins]] # deoplete {{{
repo = 'Shougo/deoplete.nvim'
depends = 'context_filetype.vim'
on_event = 'InsertEnter'
hook_add = '''
let g:deoplete#enable_at_startup = 1
set completeopt+=noselect
"set completeopt-=preview

autocmd InsertLeave,CompleteDone * if pumvisible() == 0 | silent! pclose | endif
call deoplete#custom#option('auto_refresh_delay', 1)
call deoplete#custom#option('min_pattern_length', 1)

inoremap <expr><C-h> deoplete#smart_close_popup()."\<C-h>"
inoremap <expr><BS>  deoplete#smart_close_popup()."\<C-h>"
imap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function() abort
  return deoplete#close_popup() . "\<CR>"
endfunction
"let g:cache_completed = {}
"function! s:my_cr_function() abort
"  if has_key(v:completed_item, 'word') && g:cache_completed != v:completed_item
"    let g:cache_completed = v:completed_item
"    return deoplete#close_popup()
"  else
"    return deoplete#close_popup() . "\<CR>"
"  endif
"endfunction
"imap <silent><expr> <cr> neosnippet#expandable_or_jumpable()?
"  \ "\<Plug>(neosnippet_expand_or_jump)":
"  \ deoplete#close_popup() . "\<CR>"
''' # }}}

# vim: foldmethod=marker
